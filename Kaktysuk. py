# ==================================================================================
#
#                    K A K T Y S U K - Z E R O   v1.5.1 (Rollback & Fix)
#
#         Откат к стабильной версии 1.5 с исправлением синтаксической ошибки.
#         Ничего нового. Только то, что уже работало.
#
# ==================================================================================

import sys
import time

# --- МОДУЛЬ 1: КОНСТАНТЫ И ДАННЫЕ ---
ЦЕННОСТИ_ФИГУР = {
    'П': 100, 'К': 320, 'С': 330, 'Л': 500, 'Ф': 900, 'КР': 20000,
    'п': -100, 'к': -320, 'с': -330, 'л': -500, 'ф': -900, 'кр': -20000
}

# --- МОДУЛЬ 2: ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---
def печать_доски(доска):
    res = "\n  a b c d e f g h\n +-----------------+\n"
    for номер_строки in range(7, -1, -1):
        res += f"{номер_строки + 1}|"
        for номер_столбца in range(8):
            res += f" {доска[номер_строки][номер_столбца]}"
        res += " |\n"
    res += " +-----------------+\n"
    return res

def ход_в_нотацию(ход):
    буквы = "abcdefgh"
    старт_y, старт_x = ход[0]
    конец_y, конец_x = ход[1]
    return f"{буквы[старт_x]}{старт_y+1}{буквы[конец_x]}{конец_y+1}"

def нотация_в_ход(нотация):
    буквы = {"a":0, "b":1, "c":2, "d":3, "e":4, "f":5, "g":6, "h":7}
    if len(нотация) < 4: return None
    старт_x = буквы.get(нотация[0])
    старт_y = int(нотация[1]) - 1
    конец_x = буквы.get(нотация[2])
    конец_y = int(нотация[3]) - 1
    if None in [старт_x, конец_x]: return None
    return ((старт_y, старт_x), (конец_y, конец_x))

# --- МОДУЛЬ 3: МЕХАНИКА ДВИЖЕНИЯ ---
def сделать_ход(доска, ход):
    старт_y, старт_x = ход[0]
    конец_y, конец_x = ход[1]
    фигура = доска[старт_y][старт_x]
    доска[конец_y][конец_x] = фигура
    доска[старт_y][старт_x] = '_'

def отменить_ход(доска, ход, съеденная_фигура):
    старт_y, старт_x = ход[0]
    конец_y, конец_x = ход[1]
    фигура = доска[конец_y][конец_x]
    доска[старт_y][старт_x] = фигура
    доска[конец_y][конец_x] = съеденная_фигура

# --- МОДУЛЬ 4: ГЕНЕРАТОРЫ ХОДОВ ---
def получить_ходы_для_лучевой_фигуры(доска, y, x, направления):
    цвет_фигуры = 'белый' if доска[y][x].isupper() else 'черный'
    возможные_ходы = []
    for dy, dx in направления:
        луч_y, луч_x = y + dy, x + dx
        while 0 <= луч_y < 8 and 0 <= луч_x < 8:
            целевая_фигура = доска[луч_y][луч_x]
            if целевая_фигура == '_':
                возможные_ходы.append((луч_y, луч_x))
            else:
                цвет_цели = 'белый' if целевая_фигура.isupper() else 'черный'
                if цвет_цели != цвет_фигуры:
                    возможные_ходы.append((луч_y, луч_x))
                break
            луч_y += dy
            луч_x += dx
    return возможные_ходы

def получить_ходы_ладьи(доска, y, x):
    return получить_ходы_для_лучевой_фигуры(доска, y, x, [(1, 0), (-1, 0), (0, -1), (0, 1)])

def получить_ходы_слона(доска, y, x):
    return получить_ходы_для_лучевой_фигуры(доска, y, x, [(1, 1), (1, -1), (-1, 1), (-1, -1)])

def получить_ходы_ферзя(доска, y, x):
    return получить_ходы_ладьи(доска, y, x) + получить_ходы_слона(доска, y, x)

def получить_ходы_коня(доска, y, x):
    цвет_фигуры = 'белый' if доска[y][x].isupper() else 'черный'
    возможные_ходы = []
    прыжки = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
    for dy, dx in прыжки:
        цель_y, цель_x = y + dy, x + dx
        if 0 <= цель_y < 8 and 0 <= цель_x < 8:
            целевая_фигура = доска[цель_y][цель_x]
            if целевая_фигура == '_':
                возможные_ходы.append((цель_y, цель_x))
            else:
                if ('белый' if целевая_фигура.isupper() else 'черный') != цвет_фигуры:
                    возможные_ходы.append((цель_y, цель_x))
    return возможные_ходы

def получить_ходы_пешки(доска, y, x):
    цвет_фигуры = 'белый' if доска[y][x].isupper() else 'черный'
    возможные_ходы = []
    направление = 1 if цвет_фигуры == 'белый' else -1
    цель_y = y + направление
    if 0 <= цель_y < 8 and доска[цель_y][x] == '_':
        возможные_ходы.append((цель_y, x))
        if ((цвет_фигуры == 'белый' and y == 1) or (цвет_фигуры == 'черный' and y == 6)) and доска[y + 2*направление][x] == '_':
            возможные_ходы.append((y + 2*направление, x))
    for dx in [1, -1]:
        цель_y, цель_x = y + направление, x + dx
        if 0 <= цель_y < 8 and 0 <= цель_x < 8 and доска[цель_y][цель_x] != '_':
            if ('белый' if доска[цель_y][цель_x].isupper() else 'черный') != цвет_фигуры:
                возможные_ходы.append((цель_y, цель_x))
    return возможные_ходы

def получить_ходы_короля(доска, y, x):
    цвет_фигуры = 'белый' if доска[y][x].isupper() else 'черный'
    возможные_ходы = []
    for dy in [-1, 0, 1]:
        for dx in [-1, 0, 1]:
            if dy == 0 and dx == 0:
                continue
            цель_y, цель_x = y + dy, x + dx
            if 0 <= цель_y < 8 and 0 <= цель_x < 8:
                целевая_фигура = доска[цель_y][цель_x]
                if целевая_фигура == '_':
                    возможные_ходы.append((цель_y, цель_x))
                else:
                    if ('белый' if целевая_фигура.isupper() else 'черный') != цвет_фигуры:
                        возможные_ходы.append((цель_y, цель_x))
    return возможные_ходы

# --- МОДУЛЬ 5: ГЕНЕРАЛЬНЫЙ ШТАБ ---
def получить_все_ходы(доска, цвет_игрока):
    все_ходы = []
    ФИГУРЫ_ГЕНЕРАТОРЫ = {'П': получить_ходы_пешки, 'К': получить_ходы_коня, 'С': получить_ходы_слона,
                         'Л': получить_ходы_ладьи, 'Ф': получить_ходы_ферзя, 'КР': получить_ходы_короля}
    for y in range(8):
        for x in range(8):
            фигура = доска[y][x]
            if фигура != '_':
                цвет_фигуры_на_доске = 'белый' if фигура.isupper() else 'черный'
                if цвет_фигуры_на_доске == цвет_игрока:
                    ходы = ФИГУРЫ_ГЕНЕРАТОРЫ[фигура.upper()](доска, y, x)
                    for ход_y, ход_x in ходы:
                        все_ходы.append(((y, x), (ход_y, ход_x)))
    return все_ходы

# --- МОДУЛЬ 6: ИНТЕЛЛЕКТ ---
def оценить_позицию(доска):
    оценка = 0
    for строка in доска:
        for фигура in строка:
            if фигура in ЦЕННОСТИ_ФИГУР:
                оценка += ЦЕННОСТИ_ФИГУР[фигура]
    return оценка

def minimax(доска, глубина, maximizing_player):
    if глубина == 0:
        return оценить_позицию(доска)
    
    ходы = получить_все_ходы(доска, 'белый' if maximizing_player else 'черный')
    if not ходы:
        return оценить_позицию(доска)
    
    if maximizing_player:
        max_eval = -99999
        for ход in ходы:
            съеденная = доска[ход[1][0]][ход[1][1]]
            сделать_ход(доска, ход)
            eval = minimax(доска, глубина - 1, False)
            отменить_ход(доска, ход, съеденная)
            max_eval = max(max_eval, eval)
        return max_eval
    else:
        min_eval = 99999
        for ход in ходы:
            съеденная = доска[ход[1][0]][ход[1][1]]
            сделать_ход(доска, ход)
            eval = minimax(доска, глубина - 1, True)
            отменить_ход(доска, ход, съеденная)
            min_eval = min(min_eval, eval)
        return min_eval

def найти_лучший_ход(доска, глубина, цвет_игрока):
    лучший_ход = None
    if цвет_игрока == 'белый':
        лучшая_оценка = -99999
    else:
        лучшая_оценка = 99999
    
    for ход in получить_все_ходы(доска, цвет_игрока):
        съеденная = доска[ход[1][0]][ход[1][1]]
        сделать_ход(доска, ход)
        оценка = minimax(доска, глубина - 1, цвет_игрока == 'черный')
        отменить_ход(доска, ход, съеденная)
        if цвет_игрока == 'белый':
            if оценка > лучшая_оценка:
                лучшая_оценка = оценка
                лучший_ход = ход
        else:
            if оценка < лучшая_оценка:
                лучшая_оценка = оценка
                лучший_ход = ход
    return лучший_ход

# --- МОДУЛЬ 7: UCI ИНТЕРФЕЙС ---
def лог(сообщение):
    try:
        with open("uci_log.txt", "a", encoding="utf-8") as f:
            f.write(f"{сообщение}\n")
    except:
        pass

def uci_loop():
    доска = [ ['_']*8 for _ in range(8) ]
    лог(f"\n\n--- НОВЫЙ ЗАПУСК ДВИЖКА: {time.asctime()} ---")
    
    while True:
        команда = input()
        лог(f"\n[ARENA -> LILI]: {команда}")
        части = команда.split()

        if части[0] == "uci":
            print("id name Kaktysuk-Zero v1.5.1")
            print("id author Petr & Lili")
            print("uciok")
            лог("[LILI -> ARENA]: uciok")

        elif части[0] == "isready":
            print("readyok")
            лог("[LILI -> ARENA]: readyok")

        elif части[0] == "ucinewgame":
             pass

        elif части[0] == "position":
            if части[1] == "startpos":
                доска = [ 
                    ['л','к','с','ф','кр','с','к','л'], ['п']*8, ['_']*8, ['_']*8, ['_']*8, ['_']*8, ['П']*8, ['Л','К','С','Ф','КР','С','К','Л'] 
                ]
            if "moves" in части:
                try:
                    индекс_ходов = части.index("moves") + 1
                    for нотация_хода in части[индекс_ходов:]:
                        ход = нотация_в_ход(нотация_хода)
                        if ход: сделать_ход(доска, ход)
                except Exception as e:
                    лог(f"!!! ОШИБКА при обработке ходов: {e}")
            лог("--- Состояние доски ПОСЛЕ 'position': ---")
            лог(печать_доски(доска))

        elif части[0] == "go":
            лог("Получена команда 'go'. Начинаю думать...")
            
            количество_сделанных_ходов = 0
            if "moves" in команда:
                try:
                    индекс_ходов = команда.find("moves")
                    if индекс_ходов != -1:
                        ходы_строка = команда[индекс_ходов + 6:]
                        if ходы_строка:
                            количество_сделанных_ходов = len(ходы_строка.split())
                except:
                    pass
                
            цвет_игрока = 'белый' if (количество_сделанных_ходов % 2) == 0 else 'черный'
            лог(f"Определил, что сейчас ходят: {цвет_игрока}")
            
            лучший_ход = найти_лучший_ход(доска, 2, цвет_игрока)
            
            if лучший_ход:
                print(f"bestmove {ход_в_нотацию(лучший_ход)}")
                лог(f"[LILI -> ARENA]: bestmove {ход_в_нотацию(лучший_ход)}")
            else:
                print("bestmove 0000")
                лог("[LILI -> ARENA]: bestmove 0000 (ходов не найдено)")

        elif части[0] == "quit":
            лог("--- Получена команда 'quit'. Завершаю работу.")
            break

# --- ГЛАВНАЯ ТОЧКА ВХОДА ---
if __name__ == "__main__":
    uci_loop()
